 <!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grille 1D</title>
</head>
<body>
    <h1 style="text-align: center;">Grille 1D</h1>
    <div id="grid" style="display: flex; justify-content: center;"></div>
    <script>
        //   Function
        function getRandomFromBucket(bucket) {
               var randomIndex = Math.floor(Math.random()*bucket.length);
               return bucket.splice(randomIndex, 1)[0];
            }
        
        function getRandomTargets(pointing_task_parametersObject){
            var bucket = [];
            for (var i=0;i<pointing_task_parametersObject.gridsize;i++) {
                bucket.push(i);
            }
            var targetArray = new Array(pointing_task_parametersObject.number_of_targets + 1);
            for (var i=0;i<pointing_task_parametersObject.number_of_targets+1;i++){
                targetArray[i] = getRandomFromBucket(bucket);
            }
            let position = targetArray.pop();
            let randomIndex = Math.floor(Math.random()*targetArray.length);
            let goal = targetArray[randomIndex];
            return [position, targetArray.sort(function(a,b){return a-b;}), goal];
        }

        class PointingTaskParameters{
            constructor(gridsize = 10, number_of_targets = 10, mode = 'gain'){
                this.gridsize = gridsize;
                this.number_of_targets = number_of_targets;
                this.mode = mode;
            }

            form_string(){
                var _str = '-'
                for (const item in this){
                    _str += item.toString() + ':' + this[item].toString() + '-';
                }
                return _str;
            }
        }

        class PointingTaskManager{
            constructor(){
                this.__state = null;
                this.__position_text = document.querySelector('.position');
                this.__targets_text = document.querySelector('.targets');
                this.__position = null;
                this.__targets = null;
                this.__user_action_text = document.querySelector('.user_action');
                this.__user_action = null;
                this.__assistant_action_text = document.querySelector('.assistant_action');
                this.__assistant_action = null;

            }

            get state(){
                return {'type': 'task_state', 'position': this.position, 'targets': this.targets};
            }

            get position(){
                return this.__position;
            }

            get targets(){
                return this.__targets;
            }

            set position(value){
                this.__position = value;
                this.__position_text.textContent = value.toString();
            }

            set targets(value){
                this.__targets = value;
                this.__targets_text.textContent = value.toString();
            }

            get user_action(){
                return this.__user_action;
            }

            set user_action(value){
                this.__user_action = value;
                this.__user_action_text.textContent = value.toString();
            }

            get assistant_action(){
                return this.__assistant_action;
            }

            set assistant_action(value){
                this.__assistant_action = value;
                this.__assistant_action_text.textContent = value.toString();
            }



        }


        function send_msg(msg) {
            socket.send(JSON.stringify(msg))
        }

        function update_state(received_dic){
            for (const [key, value] of Object.entries(received_dic)){
                    document.querySelector('.' + key).textContent = value;
            }

        }

        var pointing_task_parameters = new PointingTaskParameters();
        var pointing_task_manager = new PointingTaskManager();

        function on_init(received_dic){
            let params = received_dic['parameters'];
            for (const [key, value] of Object.entries(params)){
                pointing_task_parameters[key] = value;
            }
            grid.innerHTML = '';

            for (let i = 0; i < pointing_task_manager.gridsize; i++) {
                console.log('creating cell number ', i);
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.setAttribute('data-index', i)
                cell.style.backgroundColor = 'orange';
                grid.appendChild(cell);
                cell.addEventListener('click', function() {
                    pointing_task_manager.user_action = i - pointing_task_manager.position
                    pointing_task_manager.position = i;
                    updateGrid(i);
                    return_dic = { "state": pointing_task_manager.state, "reward": -.5, "is_done": false };
                    send_msg(return_dic);
            });
            }
            parameters.textContent = pointing_task_parameters.form_string();
            self_reset();
        }

        function self_reset(){
            let [_position, _targets, _goal] = getRandomTargets(pointing_task_parameters);
            pointing_task_manager.position = _position;
            pointing_task_manager.targets = _targets;
        
            send_msg(pointing_task_manager.state);
        }

        function on_reset(received_dic){
                if (received_dic['reset_dic'] == null){
                    self_reset()

                }
                else {
                    position = received_dic['reset_dic']['position'];
                    targets = received_dic['reset_dic']['targets'];
                    // Why does this not work?
                    if (!(position == pointing_task_manager.position && targets == pointing_task_manager.targets)){
                        console.log('warning, forced reset with ', position, 'versus', pointing_task_manager.position, 'and', targets, 'versus', pointing_task_manager.targets);
                        pointing_task_manager.position = position;
                        pointing_task_manager.targets = targets;
                    send_msg(pointing_task_manager.state);
                    }
                }

            }


        function unpack_actions(received_action_dic){
            action = received_action_dic["value"];
            action_value = action['values'];
            action_possible_values = action['possible_values'];
            action_array = Array();
            for (let i=0; i<action_value.length; i++){
                if (action_possible_values[i][action_value[i]] == undefined){
                    action_array.push(action_value[i]);
                }
                else{
                    action_array.push(action_possible_values[i][action_value[i]]);
                }

            }
            return action_array;
        }

        function on_assistant_action(received_dic){

            var is_done = false;

            action = unpack_actions(received_dic);
            console.log("assistant_action", action);

            pointing_task_manager.assistant_action = action;
            console.log("task  dynamics", pointing_task_manager.position, pointing_task_manager.user_action, pointing_task_manager.assistant_action);
            pointing_task_manager.position += pointing_task_manager.user_action*pointing_task_manager.assistant_action;
            updateGrid()
            return_dic = {"state": pointing_task_manager.state, "reward": -.5, "is_done": false};
            send_msg(return_dic);

        }

        function updateGrid() {
            const cells = grid.querySelectorAll('.cell');
            if (pointing_task_manager.position < cells.length) {
            cells[pointing_task_manager.position].style.backgroundColor = 'green';
            }
        }

        // start
        const grid = document.getElementById('grid');

        const socket = new WebSocket('ws://localhost:8000/');
        socket.onopen = function(event) {
            console.log('WebSocket connected');
        };

        document.addEventListener('keydown', function(event) {
            if (event.key === 'ArrowLeft') {
                socket.send('left');
            } else if (event.key === 'ArrowRight') {
                socket.send('right');
            }
        });

        socket.onmessage = function (event) {
            console.log('hhh');
            console.log(event);
            let dic_received = JSON.parse(event.data);
            let data_type = dic_received.type;
            delete dic_received.type;
            switch (data_type) {
                case 'init':
                    on_init(dic_received);
                    break;
                case 'reset':
                    on_reset(dic_received);
                    break;
                case 'user_action':
                    
                    break;
                case 'assistant_action':
                    on_assistant_action(dic_received);
                    break;
                case 'state':
                    update_state(dic_received);
                    break;
                case 'done':
                    break;
                default:
                    console.error(
                        "unsupported event", data);
            }
        };
          
        
    </script>
    <style>
        .cell {
            width: 30px;
            height: 30px;
            border: 1px solid black;
            text-align: center;
            font-size: 20px; 
            line-height: 30px; 
        }
    </style>
</body>
</html>
