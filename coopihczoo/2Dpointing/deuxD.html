<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>WebSocket 2D</title>
    <style type="text/css">
        body {
            font-family: "Courier New", sans-serif;
            text-align: center;
            cursor: default;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(20, 40px);
            gap: 1px;
            margin-top: 20px;
        }

        .cell {
            width: 40px;
            height: 40px;
            border: 1px solid black;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: default;

        }

        .cell.target {
            background-color: lightblue;
        }

        .cell.current {
            background-color: lightgreen;
        }

        .indicators {
            font-size: 1em;
        }

        .position {
            color: blue;
        }

        .targets {
            color: purple;
        }

        .cell.goal {
            background-color: rgb(222, 133, 247);
        }

        .param {
            color: red;
        }

        .state {
            font-size: 2em;
        }
        
    </style>
</head>

<body>
    <div class="grid" id="grid"></div>
    <div class="indicators">
        Position:
        <div class="position">unknown</div>
        Targets:
        <div class="targets">unknown</div>
        Goal:
        <div class="goal">Determined by User inside Bundle</div>
        Parameters:
        <div class="param">unknown</div>
    </div>

    <div class='actions'>
        User Action:
        <div class='user_action'>None Received</div>
        Assistant Action:
        <div class='assistant_action'>None Received</div>

        <div class="state">
            <span class="users">?</span> online
        </div>
    </div>
        <script>

            // ========================== functions and classes def =============

            function getRandomFromBucket(bucket) {
                var randomIndex = Math.floor(Math.random() * bucket.length);
                return bucket.splice(randomIndex, 1)[0];
            }
            function getRandomTargets(pointing_task_parametersObject) {
                var bucket = [];
                var numGrid = pointing_task_parametersObject.gridsize[0]*pointing_task_parametersObject.gridsize[1]
                for (var i = 0; i < numGrid; i++) {
                    bucket.push(i);
                }
                var targetArray = new Array(pointing_task_parametersObject.number_of_targets + 1);
                for (var i = 0; i < pointing_task_parametersObject.number_of_targets + 1; i++) {
                    targetArray[i] = getRandomFromBucket(bucket);
                }
                let position = targetArray.pop();
                let randomIndex = Math.floor(Math.random() * targetArray.length);
                let goal = targetArray[randomIndex];
                return [position, targetArray.sort(function (a, b) { return a - b; }), goal];
            }

            class PointingTaskParameters {
                constructor(gridsize = 20, number_of_targets = 8, mode = 'gain') {
                    this.gridsize = gridsize;
                    this.number_of_targets = number_of_targets;
                    this.mode = mode;
                }

                form_string() {
                    var _str = '-'
                    for (const item in this) {
                        _str += item.toString() + ':' + this[item].toString() + '-';
                    }
                    return _str;
                }
            }

            class PointingTaskManager {
                constructor() {
                    this.__state = null;
                    this.__position_text = document.querySelector('.position');
                    this.__targets_text = document.querySelector('.targets');
                    this.__position = null;
                    this.__targets = null;
                    this.__user_action_text = document.querySelector('.user_action');
                    this.__user_action = null;
                    this.__assistant_action_text = document.querySelector('.assistant_action');
                    this.__assistant_action = null;

                }

                get state() {
                    return { 'type': 'task_state', 'position': this.position, 'targets': this.targets };
                }

                get position() {
                    return this.__position;
                }

                get targets() {
                    return this.__targets;
                }

                set position(value) {
                    this.__position = value;
                    this.__position_text.textContent = value.toString();
                }

                set targets(value) {
                    this.__targets = value;
                    this.__targets_text.textContent = value.toString();
                }

                get user_action() {
                    return this.__user_action;
                }

                set user_action(value) {
                    this.__user_action = value;
                    this.__user_action_text.textContent = this.__position.toString() + "-->"+ value.toString();
                }

                get assistant_action() {
                    return this.__assistant_action;
                }

                set assistant_action(value) {
                    this.__assistant_action = value;
                    this.__assistant_action_text.textContent = value.toString();
                }



            }


            function send_msg(msg) {
                console.log('sent: ', JSON.stringify(msg))
                websocket.send(JSON.stringify(msg))
            }

            function update_state(received_dic) {
                for (const [key, value] of Object.entries(received_dic)) {
                    document.querySelector('.' + key).textContent = value;
                }

            }

            var gridContainer = document.getElementById('grid');
            
            let currentRow = 0;
            let currentCol = 0;
            let rowss = 0;
            let colsss = 0;

            // Function to create 2D grid
            function createGrid(rows, cols) {
                rowss = rows;
                colss = cols;
                gridContainer.innerHTML = ''; 
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.textContent = `${i*rows+j}`; 
                        gridContainer.appendChild(cell);
                    }
                }
            }
                        
            function cellClicked(row, col) {
                pointing_task_manager.user_action = (row, col);
                updateCurrentPosition(row, col);
                send_msg({'type': 'user_action', 'value': [row, col] , 'state':PointingTaskManager.state});
            }
            
            function setTargets(targetPositions) {
                const cells = gridContainer.querySelectorAll('.cell');
                cells.forEach((cell, index) => {
                    if (targetPositions.includes(index)) {
                        cell.classList.add('target');
                        cell.addEventListener('Enter', () => {
                            console.log("ggg");
                            cellClicked(Math.floor(index / cols), index % cols);
                        });
                    } else {
                        cell.classList.remove('target');
                    }
                });
            }   
            
            function setGoal(goalPos) {
                const cells = gridContainer.querySelectorAll('.cell');
                cells.forEach((cell, index) => {
                    if (goalPos === index) {
                        cell.classList.add('goal');
                    } else {
                        cell.classList.remove('goal');
                    }
                });
            }
            
            function updateCurrentPosition(row, col) {
                currentRow = row;
                currentCol = col;
                const cells = gridContainer.querySelectorAll('.cell');
                cells.forEach((cell, index) => {
                    if (index === row * rowss + col) {
                        cell.classList.add('current');
                    } else {
                        cell.classList.remove('current');
                    }
                });
            }
            
            function handleArrowKeyPress(event, rows, cols) {
                switch (event.key) {
                    case 'ArrowUp':
                        if (currentRow > 0) {
                            updateCurrentPosition(currentRow - 1, currentCol);
                        }
                        break;
                    case 'ArrowDown':
                        if (currentRow < rows - 1) {
                            updateCurrentPosition(currentRow + 1, currentCol);
                        }
                        break;
                    case 'ArrowLeft':
                        if (currentCol > 0) {
                            updateCurrentPosition(currentRow, currentCol - 1);
                        }
                        break;
                    case 'ArrowRight':
                        if (currentCol < cols - 1) {
                            updateCurrentPosition(currentRow, currentCol + 1);
                        }
                        break;
                    default:
                        break;
                }
            }

            function handleEnterKeyPress(event) {
                if (event.key === 'Enter') {
                    const cells = gridContainer.querySelectorAll('.cell');
                    cells.forEach((cell, index) => {
                        if ((cell.classList.contains('target')) && (cell.classList.contains('current'))) {
                            const row = Math.floor(index / rowss);
                            const col = index % rowss;
                            cellClicked(row, col);
                        }
                    });
                }
            }


            var pointing_task_parameters = new PointingTaskParameters();
            var pointing_task_manager = new PointingTaskManager();

            function on_init(received_dic) {
                let params = received_dic['init_message'];
                for (const [key, value] of Object.entries(params)) {
                    pointing_task_parameters[key] = value;
                }
                parameters.textContent = pointing_task_parameters.form_string();
                self_reset();
            }

            function self_reset() {
                let [_position, _targets, _goal] = getRandomTargets(pointing_task_parameters);
                pointing_task_manager.position = _position;
                pointing_task_manager.targets = _targets;
                pointing_task_manager.goal = _goal;

                send_msg(pointing_task_manager.state);
            }

            function on_reset(received_dic) {
                if (received_dic['reset_dic'] == null) {
                    self_reset()
                    
                    createGrid(pointing_task_parameters.gridsize[0], pointing_task_parameters.gridsize[1]);
                    
                    setTargets(pointing_task_manager.targets);
                    setGoal(pointing_task_manager.goal);

                    updateCurrentPosition(currentRow, currentCol);           
                }
                else {
                    position = received_dic['reset_dic']['position'];
                    targets = received_dic['reset_dic']['targets'];
                    // Why does this not work?
                    if (!(position == pointing_task_manager.position && targets == pointing_task_manager.targets)) {
                        console.log('warning, forced reset with ', position, 'versus', pointing_task_manager.position, 'and', targets, 'versus', pointing_task_manager.targets);
                        pointing_task_manager.position = position;
                        pointing_task_manager.targets = targets;
                        send_msg(pointing_task_manager.state);
                    }
                }

            }

            function unpack_actions(received_action_dic) {
                action = received_action_dic["value"];
                action_value = action['values'];
                console.log(action)
                console.log(action_value)
                action_possible_values = action['possible_values'];
                action_array = Array();
                action_array.push(action_value)
                // for (let i = 0; i < action_value.length; i++) {
                //     // can't make the test for null || [null] work
                //     if (action_possible_values[i][action_value[i]] == undefined) {
                //         action_array.push(action_value[i]);
                //     }
                //     else {
                //         action_array.push(action_possible_values[i][action_value[i]]);
                //     }

                // }
                return action_array;
            }

            function on_user_action(received_dic) {

                var is_done = false;

                // convert action
                action = unpack_actions(received_dic);
                console.log("user_action", action);
                pointing_task_manager.user_action = action;
                if (action == 0) {
                    is_done = true;
                }
                return_dic = { "state": pointing_task_manager.state, "reward": -.5, "is_done": is_done };
                send_msg(return_dic);

            }


            function on_assistant_action(received_dic) {

                var is_done = false;

                action = unpack_actions(received_dic);
                console.log("assistant_action", action);

                pointing_task_manager.assistant_action = action;
                console.log("task  dynamics", pointing_task_manager.position, pointing_task_manager.user_action, pointing_task_manager.assistant_action);
                updateCurrentPosition(action[0]);
                
                pointing_task_manager.position = pointing_task_manager.user_action * pointing_task_manager.assistant_action;
                return_dic = { "state": pointing_task_manager.state, "reward": -.5, "is_done": false };
                send_msg(return_dic);

            }



            // ========================== Start ========================    

            
            users = document.querySelector('.users'),
            // targets = document.querySelector('.targets'),
            // position = document.querySelector('.position'),
            goal = document.querySelector('.goal'),
            parameters = document.querySelector('.param'),
            websocket = new WebSocket("ws://127.0.0.1:4000/");

            document.addEventListener('keydown', function(event) {
            handleArrowKeyPress(event, pointing_task_parameters.gridsize[0], pointing_task_parameters.gridsize[1]);
            handleEnterKeyPress(event);
            });

            var users_actions = {};
            var iter = 0;

            websocket.onmessage = function (event) {
                console.log(event)
                let dic_received = JSON.parse(event.data);
                let data_type = dic_received.type
                delete dic_received.type
                switch (data_type) {
                    case 'init':
                        on_init(dic_received);
                        break;
                    case 'reset':
                        on_reset(dic_received);
                        break;
                    case 'user_action':
                        //on_user_action(dic_received);
                        break;
                    case 'assistant_action':
                        on_assistant_action(dic_received);
                        break;
                    case 'state':
                        update_state(dic_received);
                        break;
                    case 'done':
                        break;

                    default:
                        console.error(
                            "unsupported event", data);
                }
            };

    
    </script>
</body>

</html>